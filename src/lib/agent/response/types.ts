// ═══════════════════════════════════════════════════════════════════════════
// Response Types
// Types for formatting and structuring agent responses based on action decisions
// ═══════════════════════════════════════════════════════════════════════════

import type {
  ActionDecision,
  ExecuteToolDecision,
  ConfirmActionDecision,
  ClarifyDecision,
  RespondDecision,
  ErrorDecision,
} from "../routing/types";
import type { LLMAssumption, TokenUsage } from "../llm/types";
import type { Assumption } from "../types";

// ─────────────────────────────────────────────────────────────
// Response Metadata Types
// ─────────────────────────────────────────────────────────────

/**
 * Metadata about response generation
 */
export interface ResponseGenerationMetadata {
  /** Tokens used in generation */
  tokensUsed?: TokenUsage;

  /** Processing duration in milliseconds */
  durationMs: number;

  /** LLM model used for response generation */
  model?: string;

  /** Whether the response was generated by LLM or templated */
  generationType: "llm" | "template" | "direct";

  /** Timestamp of response generation */
  generatedAt: Date;
}

/**
 * Extended metadata for client-facing responses
 */
export interface ClientResponseMetadata extends ResponseGenerationMetadata {
  /** Audit log ID for this response */
  auditLogId?: string;

  /** Conversation ID (if in a conversation) */
  conversationId?: string;

  /** Message ID assigned to this response */
  messageId?: string;

  /** Plan ID (if part of a plan execution) */
  planId?: string;
}

// ─────────────────────────────────────────────────────────────
// Core Response Types
// ─────────────────────────────────────────────────────────────

/**
 * Response for a tool execution decision
 */
export interface ExecuteResponse {
  /** Response type discriminator */
  type: "execute";

  /** Content describing the action taken */
  content: string;

  /** Tool that was/will be executed */
  tool: string;

  /** Parameters used */
  params: Record<string, unknown>;

  /** Whether this requires approval before execution */
  requiresApproval: boolean;

  /** Approval ID if pending approval */
  approvalId?: string;

  /** Result of execution (if already executed) */
  result?: unknown;

  /** The original decision */
  decision: ExecuteToolDecision;

  /** Assumptions made (converted from LLM format) */
  assumptions: Assumption[];

  /** Overall confidence */
  confidence: number;

  /** Response metadata */
  metadata: ResponseGenerationMetadata;
}

/**
 * Response for a confirmation request decision
 */
export interface ConfirmResponse {
  /** Response type discriminator */
  type: "confirm";

  /** Content asking for confirmation */
  content: string;

  /** Tool that would be executed */
  tool: string;

  /** Parameters that would be used */
  params: Record<string, unknown>;

  /** What we're uncertain about */
  uncertainties: string[];

  /** The original decision */
  decision: ConfirmActionDecision;

  /** Assumptions to verify with user */
  assumptionsToVerify: Assumption[];

  /** Overall confidence */
  confidence: number;

  /** Response metadata */
  metadata: ResponseGenerationMetadata;
}

/**
 * Response for a clarification request decision
 */
export interface ClarifyResponse {
  /** Response type discriminator */
  type: "clarify";

  /** Content asking for clarification */
  content: string;

  /** Questions to ask the user */
  questions: string[];

  /** What information is missing */
  missingInfo: string[];

  /** Partial understanding we do have */
  partialUnderstanding?: {
    possibleIntent?: string;
    possibleTool?: string;
    recognizedEntities?: string[];
  };

  /** The original decision */
  decision: ClarifyDecision;

  /** Response metadata */
  metadata: ResponseGenerationMetadata;
}

/**
 * Response for a conversational response decision
 */
export interface ConversationalResponse {
  /** Response type discriminator */
  type: "respond";

  /** Conversational content */
  content: string;

  /** The original decision */
  decision: RespondDecision;

  /** Whether this is a simple acknowledgment */
  isSimple: boolean;

  /** Response metadata */
  metadata: ResponseGenerationMetadata;
}

/**
 * Response for an error decision
 */
export interface ErrorResponse {
  /** Response type discriminator */
  type: "error";

  /** User-friendly error message content */
  content: string;

  /** Error code */
  errorCode: string;

  /** Whether this is recoverable */
  recoverable: boolean;

  /** Suggested recovery action */
  recoverySuggestion?: string;

  /** The original decision */
  decision: ErrorDecision;

  /** Response metadata */
  metadata: ResponseGenerationMetadata;
}

/**
 * Union type for all formatted responses
 */
export type FormattedResponse =
  | ExecuteResponse
  | ConfirmResponse
  | ClarifyResponse
  | ConversationalResponse
  | ErrorResponse;

// ─────────────────────────────────────────────────────────────
// Streaming Response Types
// ─────────────────────────────────────────────────────────────

/**
 * A chunk of a streaming response
 */
export interface ResponseChunk {
  /** Content delta */
  content?: string;

  /** Whether this is the final chunk */
  done: boolean;

  /** Partial response data (in final chunk) */
  response?: FormattedResponse;

  /** Token usage (in final chunk) */
  usage?: TokenUsage;
}

/**
 * Streaming response generator options
 */
export interface StreamingOptions {
  /** Whether to include thinking events */
  includeThinking?: boolean;

  /** Whether to include tool events */
  includeToolEvents?: boolean;

  /** Callback for content chunks */
  onContent?: (chunk: string) => void;

  /** Callback when response is complete */
  onComplete?: (response: FormattedResponse) => void;

  /** Callback for errors */
  onError?: (error: Error) => void;
}

// ─────────────────────────────────────────────────────────────
// Type Guards
// ─────────────────────────────────────────────────────────────

/**
 * Check if response is an execute response
 */
export function isExecuteResponse(
  response: FormattedResponse
): response is ExecuteResponse {
  return response.type === "execute";
}

/**
 * Check if response is a confirm response
 */
export function isConfirmResponse(
  response: FormattedResponse
): response is ConfirmResponse {
  return response.type === "confirm";
}

/**
 * Check if response is a clarify response
 */
export function isClarifyResponse(
  response: FormattedResponse
): response is ClarifyResponse {
  return response.type === "clarify";
}

/**
 * Check if response is a conversational response
 */
export function isConversationalResponse(
  response: FormattedResponse
): response is ConversationalResponse {
  return response.type === "respond";
}

/**
 * Check if response is an error response
 */
export function isErrorResponse(
  response: FormattedResponse
): response is ErrorResponse {
  return response.type === "error";
}

/**
 * Check if response requires user action (confirmation, clarification, approval)
 */
export function requiresUserAction(response: FormattedResponse): boolean {
  if (isConfirmResponse(response)) return true;
  if (isClarifyResponse(response)) return true;
  if (isExecuteResponse(response) && response.requiresApproval) return true;
  return false;
}

// ─────────────────────────────────────────────────────────────
// Conversion Utilities
// ─────────────────────────────────────────────────────────────

/**
 * Convert LLMAssumption to internal Assumption type
 */
export function llmAssumptionToAssumption(
  llmAssumption: LLMAssumption,
  id?: string
): Assumption {
  return {
    id,
    statement: llmAssumption.statement,
    category: llmAssumption.category,
    evidence: llmAssumption.evidence.map((e) => ({
      source: "inference" as const,
      content: e,
      weight: llmAssumption.confidence,
    })),
    confidence: llmAssumption.confidence,
    verified: false,
  };
}

/**
 * Convert array of LLMAssumptions to Assumptions
 */
export function convertAssumptions(
  llmAssumptions: LLMAssumption[],
  idPrefix = "asmp"
): Assumption[] {
  return llmAssumptions.map((a, index) =>
    llmAssumptionToAssumption(a, `${idPrefix}_${index}`)
  );
}

/**
 * Get the action decision type from a formatted response
 */
export function getDecisionType(
  response: FormattedResponse
): ActionDecision["type"] {
  switch (response.type) {
    case "execute":
      return "execute_tool";
    case "confirm":
      return "confirm_action";
    case "clarify":
      return "clarify";
    case "respond":
      return "respond";
    case "error":
      return "error";
  }
}


